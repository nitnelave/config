#! /usr/bin/env python

import os
import ycm_core
from os.path import exists, join

from clang_helpers import PrepareClangFlags


def DirectoryOfThisScript():
    return os.path.dirname(os.path.abspath(__file__))

current_directory = DirectoryOfThisScript()


def get_extension(filename):
    return os.path.splitext(filename)[1]

# This is the single most important line in this script. Everything else is just
# nice to have but not strictly necessary.
# Find a subdirectory with a compile_commands.json file
database = None
for d in os.listdir(current_directory):
    path = join(current_directory, d)
    if exists(join(path, "compile_commands.json")):
        database = ycm_core.CompilationDatabase(path)
        break

# Alternatively, just uncomment this line
#compilation_database_folder = "build"

# This provides a safe fall-back if no compilation commands are available. You
# could also add a includes relative to your project directory, for example.
DEFAULT_FLAGS = [
    '-Wall',
    '-Wextra',
    '-std=c++11'
]
SOURCE_EXTENSIONS = ['.cpp', '.cxx', '.cc', '.c']
HEADER_EXTENSIONS = ['.h', '.hxx', '.hpp', '.hh']
PATH_FLAGS = ['-isystem', '-I', '-iquote', '--sysroot=']


def MakeRelativePathsInFlagsAbsolute(flags, working_directory):
    if not working_directory:
        return list(flags)

    def make_absolute(flag):
        if flag.startswith('/'):
            return flag
        return join(working_directory, flag)

    make_next_absolute = False

    # Check if the flag is a path flag, and process it or not, depending on
    # whether the previous one was a path flag
    def process_flag(flag):
        if make_next_absolute:
            # relative filename
            make_next_absolute = False
            return make_absolute(flag)

        # path option
        make_next_absolute = any([flag == pflag for pflag in PATH_FLAGS])

        if not make_next_absolute:
            for pflag in PATH_FLAGS:
                if flag.startswith(pflag):
                    # single word path option
                    return pflag + make_absolute(flag[len(pflag):])
        return flag
    return [process_flag(f) for f in flags]


def IsHeaderFile(filename):
  return get_extension(filename) in HEADER_EXTENSIONS


def GetCompilationInfoForFile(filename):
    # The compilation_commands.json file generated by CMake does not have entries
    # for header files. So we do our best by asking the db for flags for a
    # corresponding source file, if any. If one exists, the flags for that file
    # should be good enough.
    if IsHeaderFile(filename):
        basename = os.path.splitext(filename)[0]
        candidates = [basename + ext for ext in SOURCE_EXTENSIONS]
        for cand in filter(candidates, exists):
            compilation_info = database.GetCompilationInfoForFile(cand)
            if compilation_info.compiler_flags_:
                return compilation_info
        return None
    return database.GetCompilationInfoForFile(filename)


def FlagsForFile(filename, **kwargs):
    if database:
        # Bear in mind that compilation_info.compiler_flags_ does NOT return a
        # python list, but a "list-like" StringVec object
        compilation_info = GetCompilationInfoForFile(filename)
        if not compilation_info:
            return None

        flags = MakeRelativePathsInFlagsAbsolute(
            compilation_info.compiler_flags_,
            compilation_info.compiler_working_dir_)

    else:
        flags = DEFAULT_FLAGS

    return {
        'flags': flags,
        'do_cache': True
    }
